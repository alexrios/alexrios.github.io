<!DOCTYPE html><html lang="en" class="dark"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" href="/icon.png"><meta name="generator" content="Astro v5.5.2"><!-- Font preloads --><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet"><!-- Canonical URL --><link rel="canonical" href="https://alexrios.me/blog/goroutine-leak-detection-gc-trick/"><!-- Primary Meta Tags --><title>The GC trick that catches leaks | alexrios</title><meta name="title" content="The GC trick that catches leaks"><meta name="description" content="How Go detects leaked goroutines using garbage collection"><meta name="author" content="Alex Rios"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://alexrios.me/blog/goroutine-leak-detection-gc-trick/"><meta property="og:title" content="The GC trick that catches leaks"><meta property="og:description" content="How Go detects leaked goroutines using garbage collection"><meta property="og:image" content="https://alexrios.me/og-image/goroutine-leak-detection-gc-trick.png"><meta property="article:author" content="Alex Rios"><meta property="article:published_time" content="2025-12-18T03:00:00.000Z"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://alexrios.me/blog/goroutine-leak-detection-gc-trick/"><meta property="twitter:title" content="The GC trick that catches leaks"><meta property="twitter:description" content="How Go detects leaked goroutines using garbage collection"><meta property="twitter:image" content="https://alexrios.me/og-image/goroutine-leak-detection-gc-trick.png"><link rel="stylesheet" href="/_astro/about.mLUw1Hba.css">
<link rel="stylesheet" href="/_astro/about.82j6Vgc0.css">
<style>li[data-astro-cid-zekvapgs]:before{content:"#";margin-right:-.5rem;color:var(--theme-accent)}.active-toc[data-astro-cid-zekvapgs]{color:var(--theme-accent)}button[data-astro-cid-xuhzuiaq]{position:fixed;bottom:1rem;left:82%;display:none;height:3rem;width:3rem;align-items:center;justify-content:center;border-radius:9999px;background-color:var(--theme-accent);color:var(--theme-bg);--tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);--tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow);transition-property:all;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}button[data-astro-cid-xuhzuiaq]:hover{--tw-scale-x: 1.25;--tw-scale-y: 1.25;transform:translate(var(--tw-translate-x),var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));--tw-shadow: 0 20px 25px -5px rgb(0 0 0 / .1), 0 8px 10px -6px rgb(0 0 0 / .1);--tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);box-shadow:var(--tw-ring-offset-shadow, 0 0 #0000),var(--tw-ring-shadow, 0 0 #0000),var(--tw-shadow)}@media (min-width: 640px){button[data-astro-cid-xuhzuiaq]{bottom:2rem;height:2.5rem;width:2.5rem}}@media (min-width: 768px){button[data-astro-cid-xuhzuiaq]{left:90%}}@media (min-width: 1536px){button[data-astro-cid-xuhzuiaq]{left:75%}}
</style></head> <body> <header class="group relative mb-8 flex justify-between items-center gap-4" id="main-header" data-astro-cid-3ef6ksr2> <div class="block" data-astro-cid-3ef6ksr2> <a class="title whitespace-nowrap" href="/" aria-current="false" data-astro-cid-3ef6ksr2>alexrios</a> </div> <nav class="mt-4 bg-surface/95 sm:bg-bgColor absolute hidden top-8 w-full sm:block sm:static sm:mt-0 group-[.menu-open]:z-50 group-[.menu-open]:flex group-[.menu-open]:bg-bgColor" id="navigation-menu" aria-label="main menu" data-astro-cid-3ef6ksr2> <div class="space-y-1 px-2 pb-3 pt-2 sm:flex sm:px-0 sm:py-0 sm:space-y-0 sm:space-x-2" data-astro-cid-3ef6ksr2> <a href="/" class="block py-2 sm:py-0" title="Home" aria-current="false" data-astro-prefetch="true" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> Home </a> <a href="/about" class="block py-2 sm:py-0" title="About" aria-current="false" data-astro-prefetch="true" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> About </a> <a href="/blog" class="block py-2 sm:py-0" title="Blog" aria-current="false" data-astro-prefetch="true" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> Blog </a> <a href="/books" class="block py-2 sm:py-0" title="Books" aria-current="false" data-astro-prefetch="true" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> Books </a> <a href="/speaker" class="block py-2 sm:py-0" title="Speaker" aria-current="false" data-astro-prefetch="true" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> Speaker </a> <a href="/archive" class="block py-2 sm:py-0" title="Archive" aria-current="false" data-astro-prefetch="true" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> Archive </a>  <a href="/tags" class="sm:hidden block py-2 sm:py-0" title="tags" aria-current="false" data-astro-prefetch="true" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> Tags </a>  <a href="/series" class="sm:hidden block py-2 sm:py-0" title="series" aria-current="false" data-astro-prefetch="true" data-astro-cid-3ef6ksr2="true" data-astro-cid-eimmu3lg> Series </a>  </div> </nav> <div class="flex gap-2 items-center justify-center" data-astro-cid-3ef6ksr2> <button id="themeToggle" class="transition-all relative" aria-label="toggle theme" data-astro-cid-x3pjskd3> <svg width="25px" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" data-astro-cid-x3pjskd3> <path class="sun opacity-100 transition-all dark:scale-0 dark:opacity-0" fill-rule="evenodd" d="M12 17.5a5.5 5.5 0 1 0 0-11 5.5 5.5 0 0 0 0 11zm0 1.5a7 7 0 1 0 0-14 7 7 0 0 0 0 14zm12-7a.8.8 0 0 1-.8.8h-2.4a.8.8 0 0 1 0-1.6h2.4a.8.8 0 0 1 .8.8zM4 12a.8.8 0 0 1-.8.8H.8a.8.8 0 0 1 0-1.6h2.5a.8.8 0 0 1 .8.8zm16.5-8.5a.8.8 0 0 1 0 1l-1.8 1.8a.8.8 0 0 1-1-1l1.7-1.8a.8.8 0 0 1 1 0zM6.3 17.7a.8.8 0 0 1 0 1l-1.7 1.8a.8.8 0 1 1-1-1l1.7-1.8a.8.8 0 0 1 1 0zM12 0a.8.8 0 0 1 .8.8v2.5a.8.8 0 0 1-1.6 0V.8A.8.8 0 0 1 12 0zm0 20a.8.8 0 0 1 .8.8v2.4a.8.8 0 0 1-1.6 0v-2.4a.8.8 0 0 1 .8-.8zM3.5 3.5a.8.8 0 0 1 1 0l1.8 1.8a.8.8 0 1 1-1 1L3.5 4.6a.8.8 0 0 1 0-1zm14.2 14.2a.8.8 0 0 1 1 0l1.8 1.7a.8.8 0 0 1-1 1l-1.8-1.7a.8.8 0 0 1 0-1z" data-astro-cid-x3pjskd3></path> <path class="moon opacity-0 transition-all dark:scale-100 dark:opacity-100" fill-rule="evenodd" d="M16.5 6A10.5 10.5 0 0 1 4.7 16.4 8.5 8.5 0 1 0 16.4 4.7l.1 1.3zm-1.7-2a9 9 0 0 1 .2 2 9 9 0 0 1-11 8.8 9.4 9.4 0 0 1-.8-.3c-.4 0-.8.3-.7.7a10 10 0 0 0 .3.8 10 10 0 0 0 9.2 6 10 10 0 0 0 4-19.2 9.7 9.7 0 0 0-.9-.3c-.3-.1-.7.3-.6.7a9 9 0 0 1 .3.8z" data-astro-cid-x3pjskd3></path> </svg> </button>  <script>
  const theme = (() => {
    if (typeof localStorage !== 'undefined' && localStorage.getItem('theme')) {
      return localStorage.getItem('theme');
    }
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
      return 'dark';
    }
      return 'light';
  })();

  if (theme === 'light') {
    document.documentElement.classList.remove('dark');
  } else {
    document.documentElement.classList.add('dark');
  }

  window.localStorage.setItem('theme', theme);

  const handleToggleClick = () => {
    const element = document.documentElement;
    element.classList.toggle("dark");

    const isDark = element.classList.contains("dark");
    localStorage.setItem("theme", isDark ? "dark" : "light");
  }

  document.getElementById("themeToggle").addEventListener("click", handleToggleClick);
</script> <nav-button data-astro-cid-3ef6ksr2="true"> <div class="sm:hidden" data-astro-cid-3ef6ksr2> <span class="sr-only" data-astro-cid-3ef6ksr2>open main menu</span> <button class="group flex items-center justify-center" type="button" id="navigation-menu-btn" aria-label="Open main menu" aria-expanded="false" aria-haspopup="menu" data-astro-cid-3ef6ksr2> <!-- icon when menu is closed --> <svg class="transform transition-all duration-150 ease-out group-aria-expanded:scale-0 group-aria-expanded:opacity-0 h-6 w-6 block group-aria-expanded:hidden" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-astro-cid-3ef6ksr2> <path stroke-linecap="round" stroke-linejoin="round" d="M3.75 6.75h16.5M3.75 12h16.5m-16.5 5.25h16.5" data-astro-cid-3ef6ksr2></path> </svg> <!-- icon when menu is open --> <svg class="transform transition-all duration-150 ease-out h-6 w-6 scale-0 text-accent opacity-0 transition-all group-aria-expanded:scale-100 group-aria-expanded:opacity-100 hidden group-aria-expanded:block" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" aria-hidden="true" data-astro-cid-3ef6ksr2> <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" data-astro-cid-3ef6ksr2></path> </svg> </button> </div> </nav-button> </div> </header>  <script type="module">class e extends HTMLElement{headerEl;mobileButtonEl;menuOpen;constructor(){super(),this.headerEl=document.getElementById("main-header"),this.mobileButtonEl=this.querySelector("button"),this.menuOpen=!1,this.mobileButtonEl.addEventListener("click",this.toggleMobileMenu)}toggleMobileMenu=()=>{this.headerEl.classList.toggle("menu-open"),this.menuOpen=!this.menuOpen,this.mobileButtonEl.setAttribute("aria-expanded",this.menuOpen.toString())}}customElements.define("nav-button",e);</script> <main class="grid grid-cols-1 gap-y-16 sm:grid-cols-[3fr_1fr] sm:gap-x-4">  <article class="cody-bg prose dark:prose-invert prose-cody text-textColor max-w-4xl"> <header class="space-y-2"> <div class="aspect-h-9 aspect-w-16 mb-6 w-full flex justify-center"> <img src="/blindfolded-gc.png" alt="gc algorithm" class="m-0"> </div> <div class="md:sr-only not-sr-only"> <span>Part of series:</span> <a class="cody-link" href="/series/Goroutine Leak Detection">Goroutine Leak Detection</a> </div> <div class="flex gap-2 items-center"> <h1 class="text-3xl my-0">The GC trick that catches leaks</h1>  </div> <span class="font-semibold text-textColor flex gap-2 items-center"> <time datetime="2025-12-18T03:00:00.000Z" title="18 December 2025"> 18 December 2025 </time> <span>
/ 10 min read </span>  </span> <ul class="not-prose flex gap-2 flex-wrap"> <svg viewBox="0 0 32 32" aria-hidden="true" focusable="false" class="w-5 h-5" astro-icon="carbon:tag-group"><circle cx="10" cy="14" r="2" fill="currentColor"/><path fill="currentColor" d="M16 30a1 1 0 0 1-.71-.29L4.59 19A2 2 0 0 1 4 17.59V10a2 2 0 0 1 2-2h7.59a2 2 0 0 1 1.41.59l10.71 10.7a1 1 0 0 1 0 1.42l-9 9A1 1 0 0 1 16 30zM6 10v7.59l10 10L23.59 20l-10-10z"/><path fill="currentColor" d="M27.71 13.29 17 2.59A2 2 0 0 0 15.59 2H8a2 2 0 0 0-2 2v2h2V4h7.59l10 10-1.3 1.29 1.42 1.42 2-2a1 1 0 0 0 0-1.42z"/></svg> <li class="tag"> <a href="/tags/go">go</a> </li><li class="tag"> <a href="/tags/runtime">runtime</a> </li><li class="tag"> <a href="/tags/gc">gc</a> </li><li class="tag"> <a href="/tags/algorithms">algorithms</a> </li> </ul> </header> <hr class="my-4"> <main class="prose-sm prose-headings:font-semibold prose-headings:ml-4 prose-headings:before:absolute prose-headings:before:-ms-4 prose-headings:before:text-accent prose-headings:before:content-['#'] prose-th:before:content-none prose-a:text-accent">  <p>In the <a href="/blog/goroutine-leak-detection-intro">last post</a>, we looked at the problem of ghost goroutines (goroutines stuck waiting on channels or mutexes that have become unreachable from the rest of your program). We established that the key question isn’t “is this goroutine waiting?” but rather “<strong>CAN this goroutine ever wake up?</strong>”</p>
<p>Now let’s talk about how the runtime answers that question. The solution is elegant: make the garbage collector tell us which channels are unreachable, then check which goroutines are blocked on those channels.</p>
<p>Simple idea. <strong>Tricky</strong> implementation.</p>
<h2 id="reachability-analysis">Reachability analysis</h2>
<p>The garbage collector’s job is to identify which objects in your program are still in use and which ones are garbage. It does this through reachability analysis: starting from a set of roots (global variables, stack frames, registers), it marks everything it can reach, and anything left unmarked is garbage.</p>
<p>For goroutine leak detection, we apply the same logic to channels and synchronization primitives:</p>
<ul>
<li>If a goroutine is blocked on a channel send/receive.</li>
<li>And that channel is unreachable from any running code.</li>
<li>Then the goroutine can never wake up—it’s leaked.</li>
</ul>
<p>The trick is figuring out which channels are “unreachable from running code” without accidentally marking them as reachable just because some waiting goroutine has a reference to them.</p>
<p>Think about it: if a goroutine is blocked sending to a channel, it has a reference to that channel in its internal state (specifically, in a structure called a <a href="https://github.com/golang/go/blob/master/src/runtime/runtime2.go#L406"><code>sudog</code></a>). If the GC naively follows that reference, it would mark the channel as reachable, even though nobody <em>else</em> can reach it. We’d miss the leak.</p>
<blockquote>
<p>What we need is a way to temporarily hide those references from the GC. We want the GC to mark channels based on whether running code can reach them, not whether waiting goroutines can reach them.</p>
</blockquote>
<p>That’s exactly what the runtime does. Let me walk you through the six phases.</p>
<h2 id="phase-1-the-setup-putting-a-blindfold-on-the-gc">Phase 1: The setup (putting a blindfold on the GC)</h2>
<p>When you request a goroutineleak profile—either by calling <a href="https://github.com/golang/go/blob/master/src/runtime/pprof/pprof.go#L302"><code>pprof.Lookup("goroutineleak")</code></a> or hitting the HTTP endpoint—the runtime calls <a href="https://github.com/golang/go/blob/master/src/runtime/mgc.go#L597"><code>runtime_goroutineLeakGC()</code></a>. This triggers a special GC cycle with leak detection enabled.</p>
<p>The first thing that happens is this:</p>
<pre class="astro-code astro-code-themes catppuccin-mocha catppuccin-latte" style="background-color:#1e1e2e;--shiki-dark-bg:#eff1f5;color:#cdd6f4;--shiki-dark:#4c4f69; overflow-x: auto;" tabindex="0" data-language="go"><code><span class="line"><span style="color:#CDD6F4;--shiki-dark:#4C4F69">work</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">goroutineLeak</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">enabled </span><span style="color:#94E2D5;--shiki-dark:#179299">=</span><span style="color:#FAB387;--shiki-dark:#FE640B"> true</span></span>
<span class="line"><span style="color:#89B4FA;font-style:italic;--shiki-dark:#1E66F5;--shiki-dark-font-style:italic">setSyncObjectsUntraceable</span><span style="color:#9399B2;--shiki-dark:#7C7F93">()</span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/master/src/runtime/mgc.go#L1254"><code>setSyncObjectsUntraceable()</code></a> is where the <del>magic</del> cleverness starts. It scans through every goroutine in the program and, for any goroutine that’s blocked on a channel or sync primitive, it temporarily makes those references “invisible” to the garbage collector.</p>
<p>Specifically, it modifies the <code>sudog</code> structures (the runtime’s internal representation of a goroutine waiting on something). For channel operations, it hides the <code>sudog.c</code> pointer (which points to the channel). For sync primitives like mutexes, it hides the <code>sudog.elem</code> pointer (which points to the mutex or WaitGroup or condition variable).</p>
<p>“Hiding” in this context means calling <a href="https://github.com/golang/go/blob/master/src/runtime/runtime2.go#L344"><code>setUntraceable()</code></a> on the pointer, which sets its lowest bit—turning it into an invalid pointer that the GC won’t follow. Later, <a href="https://github.com/golang/go/blob/master/src/runtime/runtime2.go#L352"><code>setTraceable()</code></a> clears the bit to restore the original pointer value.</p>
<p>It’s like putting a blindfold on the garbage collector. We want it to mark channels and mutexes based on reachability from running goroutines, from global variables, from active stack frames, not from waiting goroutines. Those waiting goroutines might be leaked, and we don’t want their references keeping objects alive in the “reachability” graph.</p>
<h2 id="phase-2-gc-marking-with-selective-vision">Phase 2: GC marking (with selective vision)</h2>
<p>Now the GC runs normally, but with a twist. It marks all the objects reachable from the usual roots:</p>
<ul>
<li>Running and runnable goroutines.</li>
<li>Global variables.</li>
<li>Stack frames.</li>
<li>Registers.</li>
</ul>
<p>But critically, it does <strong>not</strong> follow the hidden <code>sudog</code> pointers we marked in Phase 1. So a channel that’s only reachable from waiting goroutines won’t get marked. From the GC’s perspective, it’s as if those waiting goroutines don’t have references to their channels at all.</p>
<p>After the marking phase completes, we have a set of channels and sync primitives that are marked (reachable from running code) and a set that is unmarked (only reachable from waiting goroutines, if at all).</p>
<h2 id="phase-3-the-detection-algorithm-can-you-wake-up">Phase 3: The detection algorithm (can you wake up?)</h2>
<p>This is the heart of the leak detector. For each waiting goroutine, the runtime asks:</p>
<blockquote>
<p><strong>Is there any path for this goroutine to wake up?</strong></p>
</blockquote>
<p>The logic is implemented in a function called <a href="https://github.com/golang/go/blob/master/src/runtime/mgc.go#L1176"><code>isMaybeRunnable()</code></a>:</p>
<pre class="astro-code astro-code-themes catppuccin-mocha catppuccin-latte" style="background-color:#1e1e2e;--shiki-dark-bg:#eff1f5;color:#cdd6f4;--shiki-dark:#4c4f69; overflow-x: auto;" tabindex="0" data-language="go"><code><span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">func</span><span style="color:#9399B2;--shiki-dark:#7C7F93"> (</span><span style="color:#EBA0AC;font-style:italic;--shiki-dark:#E64553;--shiki-dark-font-style:italic">gp </span><span style="color:#94E2D5;--shiki-dark:#179299">*</span><span style="color:#F9E2AF;font-style:italic;--shiki-dark:#DF8E1D;--shiki-dark-font-style:italic">g</span><span style="color:#9399B2;--shiki-dark:#7C7F93">)</span><span style="color:#89B4FA;font-style:italic;--shiki-dark:#1E66F5;--shiki-dark-font-style:italic"> isMaybeRunnable</span><span style="color:#9399B2;--shiki-dark:#7C7F93">()</span><span style="color:#CBA6F7;--shiki-dark:#8839EF"> bool</span><span style="color:#9399B2;--shiki-dark:#7C7F93"> {</span></span>
<span class="line"><span style="color:#6C7086;font-style:italic;--shiki-dark:#9CA0B0;--shiki-dark-font-style:italic">    // If not waiting, it's obviously runnable</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">    if</span><span style="color:#89B4FA;font-style:italic;--shiki-dark:#1E66F5;--shiki-dark-font-style:italic"> readgstatus</span><span style="color:#9399B2;--shiki-dark:#7C7F93">(</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">gp</span><span style="color:#9399B2;--shiki-dark:#7C7F93">)</span><span style="color:#94E2D5;--shiki-dark:#179299"> !=</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> _Gwaiting </span><span style="color:#9399B2;--shiki-dark:#7C7F93">{</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">        return</span><span style="color:#FAB387;--shiki-dark:#FE640B"> true</span></span>
<span class="line"><span style="color:#9399B2;--shiki-dark:#7C7F93">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">    switch</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> gp</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">waitreason </span><span style="color:#9399B2;--shiki-dark:#7C7F93">{</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">    case</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> waitReasonSelectNoCases</span><span style="color:#9399B2;--shiki-dark:#7C7F93">,</span></span>
<span class="line"><span style="color:#CDD6F4;--shiki-dark:#4C4F69">         waitReasonChanSendNilChan</span><span style="color:#9399B2;--shiki-dark:#7C7F93">,</span></span>
<span class="line"><span style="color:#CDD6F4;--shiki-dark:#4C4F69">         waitReasonChanReceiveNilChan</span><span style="color:#9399B2;--shiki-dark:#7C7F93">:</span></span>
<span class="line"><span style="color:#6C7086;font-style:italic;--shiki-dark:#9CA0B0;--shiki-dark-font-style:italic">        // These are NEVER runnable by language semantics</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">        return</span><span style="color:#FAB387;--shiki-dark:#FE640B"> false</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">    case</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> waitReasonChanReceive</span><span style="color:#9399B2;--shiki-dark:#7C7F93">,</span></span>
<span class="line"><span style="color:#CDD6F4;--shiki-dark:#4C4F69">         waitReasonSelect</span><span style="color:#9399B2;--shiki-dark:#7C7F93">,</span></span>
<span class="line"><span style="color:#CDD6F4;--shiki-dark:#4C4F69">         waitReasonChanSend</span><span style="color:#9399B2;--shiki-dark:#7C7F93">:</span></span>
<span class="line"><span style="color:#6C7086;font-style:italic;--shiki-dark:#9CA0B0;--shiki-dark-font-style:italic">        // Check if ANY of the channels this goroutine is waiting on is marked</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">        for</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> sg </span><span style="color:#94E2D5;--shiki-dark:#179299">:=</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> gp</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">waiting</span><span style="color:#9399B2;--shiki-dark:#7C7F93">;</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> sg </span><span style="color:#94E2D5;--shiki-dark:#179299">!=</span><span style="color:#F38BA8;--shiki-dark:#D20F39"> nil</span><span style="color:#9399B2;--shiki-dark:#7C7F93">;</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> sg </span><span style="color:#94E2D5;--shiki-dark:#179299">=</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> sg</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">waitlink </span><span style="color:#9399B2;--shiki-dark:#7C7F93">{</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">            if</span><span style="color:#89B4FA;font-style:italic;--shiki-dark:#1E66F5;--shiki-dark-font-style:italic"> isMarkedOrNotInHeap</span><span style="color:#9399B2;--shiki-dark:#7C7F93">(</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">unsafe</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#89B4FA;font-style:italic;--shiki-dark:#1E66F5;--shiki-dark-font-style:italic">Pointer</span><span style="color:#9399B2;--shiki-dark:#7C7F93">(</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">sg</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">c</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#89B4FA;font-style:italic;--shiki-dark:#1E66F5;--shiki-dark-font-style:italic">get</span><span style="color:#9399B2;--shiki-dark:#7C7F93">()))</span><span style="color:#9399B2;--shiki-dark:#7C7F93"> {</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">                return</span><span style="color:#FAB387;--shiki-dark:#FE640B"> true</span><span style="color:#6C7086;font-style:italic;--shiki-dark:#9CA0B0;--shiki-dark-font-style:italic">  // At least one channel is reachable!</span></span>
<span class="line"><span style="color:#9399B2;--shiki-dark:#7C7F93">            }</span></span>
<span class="line"><span style="color:#9399B2;--shiki-dark:#7C7F93">        }</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">        return</span><span style="color:#FAB387;--shiki-dark:#FE640B"> false</span><span style="color:#6C7086;font-style:italic;--shiki-dark:#9CA0B0;--shiki-dark-font-style:italic">  // No channels are reachable, this is a leak</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">    case</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> waitReasonSyncCondWait</span><span style="color:#9399B2;--shiki-dark:#7C7F93">,</span></span>
<span class="line"><span style="color:#CDD6F4;--shiki-dark:#4C4F69">         waitReasonSyncWaitGroupWait</span><span style="color:#9399B2;--shiki-dark:#7C7F93">,</span></span>
<span class="line"><span style="color:#CDD6F4;--shiki-dark:#4C4F69">         waitReasonSyncMutexLock</span><span style="color:#9399B2;--shiki-dark:#7C7F93">,</span></span>
<span class="line"><span style="color:#CDD6F4;--shiki-dark:#4C4F69">         waitReasonSyncRWMutexLock</span><span style="color:#9399B2;--shiki-dark:#7C7F93">,</span></span>
<span class="line"><span style="color:#CDD6F4;--shiki-dark:#4C4F69">         waitReasonSyncRWMutexRLock</span><span style="color:#9399B2;--shiki-dark:#7C7F93">:</span></span>
<span class="line"><span style="color:#6C7086;font-style:italic;--shiki-dark:#9CA0B0;--shiki-dark-font-style:italic">        // Check if the sync primitive is marked</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">        if</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> gp</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">waiting </span><span style="color:#94E2D5;--shiki-dark:#179299">!=</span><span style="color:#F38BA8;--shiki-dark:#D20F39"> nil</span><span style="color:#9399B2;--shiki-dark:#7C7F93"> {</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">            return</span><span style="color:#89B4FA;font-style:italic;--shiki-dark:#1E66F5;--shiki-dark-font-style:italic"> isMarkedOrNotInHeap</span><span style="color:#9399B2;--shiki-dark:#7C7F93">(</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">gp</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">waiting</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">elem</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#89B4FA;font-style:italic;--shiki-dark:#1E66F5;--shiki-dark-font-style:italic">get</span><span style="color:#9399B2;--shiki-dark:#7C7F93">())</span></span>
<span class="line"><span style="color:#9399B2;--shiki-dark:#7C7F93">        }</span></span>
<span class="line"><span style="color:#9399B2;--shiki-dark:#7C7F93">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6C7086;font-style:italic;--shiki-dark:#9CA0B0;--shiki-dark-font-style:italic">    // For other wait reasons, assume runnable</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">    return</span><span style="color:#FAB387;--shiki-dark:#FE640B"> true</span></span>
<span class="line"><span style="color:#9399B2;--shiki-dark:#7C7F93">}</span></span></code></pre>
<p>I know that’s a lot to take in. Let’s break down what this is doing:</p>
<p><strong>For nil channels and <code>select{}</code> with no cases</strong>: These are never runnable. The language spec guarantees that sending to or receiving from a nil channel blocks forever, and a select with no cases is explicitly documented as blocking forever. Easy call! These are leaked by definition.</p>
<p><strong>For regular channel operations</strong>: The goroutine might be waiting on one or more channels (a <code>select</code> can have multiple cases). We check if <em>any</em> of those channels was marked by the GC. If at least one was marked, someone somewhere in the program has a reference to it, there’s a path for the goroutine to wake up. If <em>none</em> of the channels were marked, nobody can send/receive on them, and the goroutine is stuck forever.</p>
<p><strong>For sync primitives</strong>: Similar logic. If the mutex/WaitGroup/Cond that the goroutine is waiting on was marked, someone could unlock it or call Done() or Signal(). If it wasn’t marked, the goroutine is leaked.</p>
<p>The question the algorithm is asking isn’t “is this goroutine waiting?” It’s “<strong>CAN this goroutine ever wake up?</strong>” And the answer depends entirely on whether someone, somewhere, has a reference to the thing it’s waiting on.</p>
<blockquote>
<p>If the channel or mutex isn’t marked by the GC, nobody else has a reference to it. The goroutine is waiting for something that the rest of the program has completely forgotten about.</p>
</blockquote>
<h2 id="phase-4-partitioning-runnable-vs-leaked">Phase 4: Partitioning (runnable vs. leaked)</h2>
<p>Once we’ve checked every goroutine with <a href="https://github.com/golang/go/blob/master/src/runtime/mgc.go#L1180"><code>isMaybeRunnable()</code></a>, we need to partition them into two groups: goroutines that <strong>might wake up</strong>, and goroutines that <strong>definitely won’t</strong>.</p>
<p>The runtime uses a clever two-pointer partitioning algorithm in <a href="https://github.com/golang/go/blob/master/src/runtime/mgc.go#L1222"><code>findMaybeRunnableGoroutines()</code></a>:</p>
<pre class="astro-code astro-code-themes catppuccin-mocha catppuccin-latte" style="background-color:#1e1e2e;--shiki-dark-bg:#eff1f5;color:#cdd6f4;--shiki-dark:#4c4f69; overflow-x: auto;" tabindex="0" data-language="go"><code><span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">var</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> vIndex</span><span style="color:#9399B2;--shiki-dark:#7C7F93">,</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> ivIndex </span><span style="color:#CBA6F7;--shiki-dark:#8839EF">int</span><span style="color:#94E2D5;--shiki-dark:#179299"> =</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> work</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">nMaybeRunnableStackRoots</span><span style="color:#9399B2;--shiki-dark:#7C7F93">,</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> work</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">nStackRoots</span></span>
<span class="line"></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">for</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> vIndex </span><span style="color:#94E2D5;--shiki-dark:#179299">&#x3C;</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> ivIndex </span><span style="color:#9399B2;--shiki-dark:#7C7F93">{</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">    if</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> work</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">stackRoots</span><span style="color:#9399B2;--shiki-dark:#7C7F93">[</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">vIndex</span><span style="color:#9399B2;--shiki-dark:#7C7F93">].</span><span style="color:#89B4FA;font-style:italic;--shiki-dark:#1E66F5;--shiki-dark-font-style:italic">isMaybeRunnable</span><span style="color:#9399B2;--shiki-dark:#7C7F93">()</span><span style="color:#9399B2;--shiki-dark:#7C7F93"> {</span></span>
<span class="line"><span style="color:#CDD6F4;--shiki-dark:#4C4F69">        vIndex</span><span style="color:#94E2D5;--shiki-dark:#179299">++</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">        continue</span></span>
<span class="line"><span style="color:#9399B2;--shiki-dark:#7C7F93">    }</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">    for</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> ivIndex </span><span style="color:#94E2D5;--shiki-dark:#179299">=</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> ivIndex </span><span style="color:#94E2D5;--shiki-dark:#179299">-</span><span style="color:#FAB387;--shiki-dark:#FE640B"> 1</span><span style="color:#9399B2;--shiki-dark:#7C7F93">;</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> ivIndex </span><span style="color:#94E2D5;--shiki-dark:#179299">!=</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> vIndex</span><span style="color:#9399B2;--shiki-dark:#7C7F93">;</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> ivIndex</span><span style="color:#94E2D5;--shiki-dark:#179299">--</span><span style="color:#9399B2;--shiki-dark:#7C7F93"> {</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">        if</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> gp </span><span style="color:#94E2D5;--shiki-dark:#179299">:=</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> work</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">stackRoots</span><span style="color:#9399B2;--shiki-dark:#7C7F93">[</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">ivIndex</span><span style="color:#9399B2;--shiki-dark:#7C7F93">];</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> gp</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#89B4FA;font-style:italic;--shiki-dark:#1E66F5;--shiki-dark-font-style:italic">isMaybeRunnable</span><span style="color:#9399B2;--shiki-dark:#7C7F93">()</span><span style="color:#9399B2;--shiki-dark:#7C7F93"> {</span></span>
<span class="line"><span style="color:#CDD6F4;--shiki-dark:#4C4F69">            work</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">stackRoots</span><span style="color:#9399B2;--shiki-dark:#7C7F93">[</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">ivIndex</span><span style="color:#9399B2;--shiki-dark:#7C7F93">]</span><span style="color:#94E2D5;--shiki-dark:#179299"> =</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> work</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">stackRoots</span><span style="color:#9399B2;--shiki-dark:#7C7F93">[</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">vIndex</span><span style="color:#9399B2;--shiki-dark:#7C7F93">]</span></span>
<span class="line"><span style="color:#CDD6F4;--shiki-dark:#4C4F69">            work</span><span style="color:#9399B2;--shiki-dark:#7C7F93">.</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">stackRoots</span><span style="color:#9399B2;--shiki-dark:#7C7F93">[</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">vIndex</span><span style="color:#9399B2;--shiki-dark:#7C7F93">]</span><span style="color:#94E2D5;--shiki-dark:#179299"> =</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> gp</span></span>
<span class="line"><span style="color:#CDD6F4;--shiki-dark:#4C4F69">            vIndex</span><span style="color:#94E2D5;--shiki-dark:#179299">++</span></span>
<span class="line"><span style="color:#CBA6F7;--shiki-dark:#8839EF">            break</span></span>
<span class="line"><span style="color:#9399B2;--shiki-dark:#7C7F93">        }</span></span>
<span class="line"><span style="color:#9399B2;--shiki-dark:#7C7F93">    }</span></span>
<span class="line"><span style="color:#9399B2;--shiki-dark:#7C7F93">}</span></span></code></pre>
<p>This is essentially a partition operation, like the partition step in quicksort, except instead of comparing against a pivot, we’re testing whether each goroutine is maybe-runnable.</p>
<p>After this runs:</p>
<ul>
<li>Everything to the left of <code>vIndex</code> is maybe-runnable</li>
<li>Everything to the right of <code>vIndex</code> is leaked</li>
</ul>
<p>It’s like sorting, but the comparison function is “can this goroutine ever wake up?” That’s a question I never thought I’d need to ask at scale, but here we are.</p>
<h2 id="phase-5-status-change-marking-the-leaked">Phase 5: Status change (marking the leaked)</h2>
<p>For each goroutine that we’ve determined is leaked, <a href="https://github.com/golang/go/blob/master/src/runtime/proc.go#L1277">the runtime changes its status</a>:</p>
<pre class="astro-code astro-code-themes catppuccin-mocha catppuccin-latte" style="background-color:#1e1e2e;--shiki-dark-bg:#eff1f5;color:#cdd6f4;--shiki-dark:#4c4f69; overflow-x: auto;" tabindex="0" data-language="go"><code><span class="line"><span style="color:#89B4FA;font-style:italic;--shiki-dark:#1E66F5;--shiki-dark-font-style:italic">casgstatus</span><span style="color:#9399B2;--shiki-dark:#7C7F93">(</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69">gp</span><span style="color:#9399B2;--shiki-dark:#7C7F93">,</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> _Gwaiting</span><span style="color:#9399B2;--shiki-dark:#7C7F93">,</span><span style="color:#CDD6F4;--shiki-dark:#4C4F69"> _Gleaked</span><span style="color:#9399B2;--shiki-dark:#7C7F93">)</span></span></code></pre>
<p><a href="https://github.com/golang/go/blob/master/src/runtime/runtime2.go#L94"><code>_Gleaked</code></a> is a <strong>brand new goroutine state</strong>, introduced specifically for this feature. It’s value 10 in the goroutine status enum. When you print a stack trace for a leaked goroutine, the runtime annotates it with <code>(leaked)</code>:</p>
<pre class="astro-code astro-code-themes catppuccin-mocha catppuccin-latte" style="background-color:#1e1e2e;--shiki-dark-bg:#eff1f5;color:#cdd6f4;--shiki-dark:#4c4f69; overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>goroutine 42 [chan send (leaked)]:</span></span></code></pre>
<p>This status change is important for two reasons:</p>
<ol>
<li>It persists even after the GC cycle completes, so the profile collection code can identify leaked goroutines.</li>
<li>It shows up in crash dumps and debug output, making it immediately obvious that a goroutine is not just waiting, but leaked.</li>
</ol>
<p>The runtime also does one more important thing here: for each leaked goroutine, it marks the channels or sync primitives that caused the leak, ensuring they’re preserved even though they’re technically unreachable. We don’t want the GC to actually <em>collect</em> these objects, that would make debugging harder. We just wanted to know they were unreachable.</p>
<h2 id="phase-6-cleanup-and-profile-generation">Phase 6: Cleanup and profile generation</h2>
<p>After the GC cycle completes, the runtime runs <a href="https://github.com/golang/go/blob/master/src/runtime/mgc.go#L1281"><code>gcRestoreSyncObjects()</code></a> to restore all those hidden pointers we set in Phase 1. The <code>sudog</code>s go back to pointing at their channels and mutexes normally.</p>
<p>But the leaked status persists! Each goroutine that we marked with <code>_Gleaked</code> stays in that state. The count of leaked goroutines is stored in <code>work.goroutineLeak.count</code>.</p>
<p>When you request the goroutineleak profile, the profile collection code scans through all goroutines and outputs stack traces for anything with the <code>_Gleaked</code> status.</p>
<h2 id="the-iterative-nature">The iterative nature</h2>
<p>Here’s something subtle: leak detection is iterative. After the first round of marking and partitioning, the runtime might discover new runnable goroutines.</p>
<p>Why? Because some goroutines might be blocked on channels that are only reachable from other waiting goroutines. In the first iteration, those channels aren’t marked. But if we determine that some of those goroutines are actually runnable (because their channels <em>are</em> reachable), we need to run another iteration of marking.</p>
<p>The algorithm continues until it reaches a fixed point. A state where no new runnable goroutines are discovered. This handles complex dependency chains where goroutines are waiting on each other in intricate ways.</p>
<p>For most programs, this converges quickly. But the fact that it’s designed to handle arbitrary complexity shows the thoughtfulness that went into this implementation.</p>
<h2 id="what-gets-detected-and-what-doesnt">What gets detected (and what doesn’t)</h2>
<p>Let’s be explicit about coverage.</p>
<p>The leak detector catches goroutines blocked on:</p>
<ul>
<li><strong>Channel send/receive operations</strong>: unbuffered and buffered channels.</li>
<li><strong>Select statements</strong>: both single-channel and multi-channel cases.</li>
<li><strong>sync.Mutex</strong>: Lock operations.</li>
<li><strong>sync.RWMutex</strong>: Both RLock and Lock operations.</li>
<li><strong>sync.WaitGroup</strong>: Wait operations.</li>
<li><strong>sync.Cond</strong>: Wait operations.</li>
</ul>
<p>What it <strong>doesn’t</strong> detect:</p>
<ul>
<li>Goroutines where the channel/mutex is reachable through a <strong>global variable</strong>.</li>
<li>Goroutines where the channel/mutex is reachable through <strong>local variables of running goroutines</strong>.</li>
<li>Goroutines blocked on I/O, syscalls, or <code>time.Sleep</code>.</li>
<li>Goroutines that are CPU-bound in infinite loops.</li>
</ul>
<blockquote>
<p>And you know what? That’s fine. These are edge cases. The detector catches the common patterns that cause real problems in production. The ones where you accidentally orphan a goroutine by letting its channel fall out of scope.</p>
</blockquote>
<p>The global variable case is actually a feature, not a bug. If you have a global channel, it’s reasonable to have goroutines waiting on it indefinitely, that might be part of your program’s design. Same with channels in long-running goroutines. The leak detector specifically targets the case where <em>nobody</em> can reach the channel anymore.</p>
<h2 id="the-cleverness">The cleverness</h2>
<p>What I find elegant about this design is how little new infrastructure it required. The runtime didn’t add a whole new leak detection subsystem. Instead, it used the existing GC marking phase. Added a small bit of state tracking to sudogs. Introduced one new goroutine status. Hooked into the existing pprof infrastructure.</p>
<p>The zero overhead is real. When you’re not actively requesting a leak profile, this feature adds literally nothing to your program’s runtime. No extra goroutines, no background sampling, no memory overhead. It only does work when you explicitly ask for it.</p>
<p>They didn’t add a leak detector to the runtime. They taught the garbage collector how to recognize leaks. That’s the kind of solution that makes you appreciate the depth of understanding required to work on a production runtime.</p>
<h2 id="whats-next">What’s next</h2>
<p>Now that you understand <em>how</em> the detector works, the next question is: what does it catch? What do real goroutine leaks look like in the wild?</p>
<p>In the next post, we’ll look at five specific leak patterns, pulled from actual bugs in major Go projects.</p>
<p>Each one has its own flavor of “oh no,” and each one shows up in the test suite because it was a real bug that made it to production.</p>
<hr>
<p><strong>Previous</strong>: <a href="/blog/goroutine-leak-detection-intro">← Hunting Ghost Goroutines</a>
<strong>Next</strong>: SOON TM.</p>  </main> <button id="back-to-top-btn" aria-label="back to top" class="z-50" data-astro-cid-xuhzuiaq> <svg viewBox="0 0 32 32" aria-hidden="true" focusable="false" data-astro-cid-xuhzuiaq="true" class="w-7 h-7 sm:w-5 s:h-6" astro-icon="carbon:arrow-up"><path fill="currentColor" d="M16 4 6 14l1.41 1.41L15 7.83V28h2V7.83l7.59 7.58L26 14 16 4z"/></svg> </button>  <script type="module">const e=document.getElementById("back-to-top-btn");e&&(e.addEventListener("click",()=>{document.body.scrollTop=0,document.documentElement.scrollTop=0}),window.addEventListener("scroll",()=>{window.scrollY<document.documentElement.clientHeight?(e.classList.remove("fade-in"),e.classList.add("fade-out"),e.style.display="flex"):(e.classList.remove("fade-out"),e.classList.add("fade-in"))}));</script> </article>   <aside class="hidden sm:block"> <div class="flex flex-col space-y-2"> <h2 class="font-semibold text-lg text-textColor">Alex Rios</h2> <p>alexrios.me</p> <div class="flex flex-wrap items-end gap-x-4"> <ul class="flex flex-wrap flex-1 items-center gap-x-2 sm:flex-initial"> <li class="flex"> <a class="inline-block p-1 sm:hover:text-accent hover:animate-spin" href="https://github.com/alexrios" target="_blank" rel="noopener noreferrer" title="Github"> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" class="h-5 w-5" astro-icon="mdi:github"><path fill="currentColor" d="M12 2A10 10 0 0 0 2 12c0 4.42 2.87 8.17 6.84 9.5.5.08.66-.23.66-.5v-1.69c-2.77.6-3.36-1.34-3.36-1.34-.46-1.16-1.11-1.47-1.11-1.47-.91-.62.07-.6.07-.6 1 .07 1.53 1.03 1.53 1.03.87 1.52 2.34 1.07 2.91.83.09-.65.35-1.09.63-1.34-2.22-.25-4.55-1.11-4.55-4.92 0-1.11.38-2 1.03-2.71-.1-.25-.45-1.29.1-2.64 0 0 .84-.27 2.75 1.02.79-.22 1.65-.33 2.5-.33.85 0 1.71.11 2.5.33 1.91-1.29 2.75-1.02 2.75-1.02.55 1.35.2 2.39.1 2.64.65.71 1.03 1.6 1.03 2.71 0 3.82-2.34 4.66-4.57 4.91.36.31.69.92.69 1.85V21c0 .27.16.59.67.5C19.14 20.16 22 16.42 22 12A10 10 0 0 0 12 2z"/></svg> <span class="sr-only">Github</span> </a> </li><li class="flex"> <a class="inline-block p-1 sm:hover:text-accent hover:animate-spin" href="https://linkedin.com/in/the-alex-rios" target="_blank" rel="noopener noreferrer" title="LinkedIn"> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" class="h-5 w-5" astro-icon="mdi:linkedin"><path fill="currentColor" d="M19 3a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14m-.5 15.5v-5.3a3.26 3.26 0 0 0-3.26-3.26c-.85 0-1.84.52-2.32 1.3v-1.11h-2.79v8.37h2.79v-4.93c0-.77.62-1.4 1.39-1.4a1.4 1.4 0 0 1 1.4 1.4v4.93h2.79M6.88 8.56a1.68 1.68 0 0 0 1.68-1.68c0-.93-.75-1.69-1.68-1.69a1.69 1.69 0 0 0-1.69 1.69c0 .93.76 1.68 1.69 1.68m1.39 9.94v-8.37H5.5v8.37h2.77z"/></svg> <span class="sr-only">LinkedIn</span> </a> </li><li class="flex"> <a class="inline-block p-1 sm:hover:text-accent hover:animate-spin" href="https://x.com/alextrending" target="_blank" rel="noopener noreferrer" title="twitter"> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" class="h-5 w-5" astro-icon="mdi:twitter"><path fill="currentColor" d="M22.46 6c-.77.35-1.6.58-2.46.69.88-.53 1.56-1.37 1.88-2.38-.83.5-1.75.85-2.72 1.05C18.37 4.5 17.26 4 16 4c-2.35 0-4.27 1.92-4.27 4.29 0 .34.04.67.11.98C8.28 9.09 5.11 7.38 3 4.79c-.37.63-.58 1.37-.58 2.15 0 1.49.75 2.81 1.91 3.56-.71 0-1.37-.2-1.95-.5v.03c0 2.08 1.48 3.82 3.44 4.21a4.22 4.22 0 0 1-1.93.07 4.28 4.28 0 0 0 4 2.98 8.521 8.521 0 0 1-5.33 1.84c-.34 0-.68-.02-1.02-.06C3.44 20.29 5.7 21 8.12 21 16 21 20.33 14.46 20.33 8.79c0-.19 0-.37-.01-.56.84-.6 1.56-1.36 2.14-2.23z"/></svg> <span class="sr-only">twitter</span> </a> </li><li class="flex"> <a class="inline-block p-1 sm:hover:text-accent hover:animate-spin" href="/rss.xml" target="_blank" rel="noopener noreferrer" title="rss"> <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false" class="h-5 w-5" astro-icon="mdi:rss"><path fill="currentColor" d="M6.18 15.64a2.18 2.18 0 0 1 2.18 2.18C8.36 19 7.38 20 6.18 20 5 20 4 19 4 17.82a2.18 2.18 0 0 1 2.18-2.18M4 4.44A15.56 15.56 0 0 1 19.56 20h-2.83A12.73 12.73 0 0 0 4 7.27V4.44m0 5.66a9.9 9.9 0 0 1 9.9 9.9h-2.83A7.07 7.07 0 0 0 4 12.93V10.1z"/></svg> <span class="sr-only">rss</span> </a> </li> </ul> </div> <span class="!my-4 text-accent" aria-hidden>---</span>
                    <p> How Go detects leaked goroutines using garbage collection </p> <div class="pt-2 hidden md:block"> <span>Part of series: </span> <br> <ul> <li><a class="cody-link" href="/series/Goroutine Leak Detection">Goroutine Leak Detection</a></li> </ul> </div>  </div> <nav class="sticky top-20 order-2 hidden basis-64 lg:block"> <hr> <h2 class="font-bold text-lg">Table of Contents</h2> <ul class="-me-32" id="toc"> <li data-astro-cid-zekvapgs> <a href="#reachability-analysis" id="toc-reachability-analysis" data-astro-cid-zekvapgs> Reachability analysis </a>  </li> <li data-astro-cid-zekvapgs> <a href="#phase-1-the-setup-putting-a-blindfold-on-the-gc" id="toc-phase-1-the-setup-putting-a-blindfold-on-the-gc" data-astro-cid-zekvapgs> Phase 1: The setup (putting a blindfold on the GC) </a>  </li> <li data-astro-cid-zekvapgs> <a href="#phase-2-gc-marking-with-selective-vision" id="toc-phase-2-gc-marking-with-selective-vision" data-astro-cid-zekvapgs> Phase 2: GC marking (with selective vision) </a>  </li> <li data-astro-cid-zekvapgs> <a href="#phase-3-the-detection-algorithm-can-you-wake-up" id="toc-phase-3-the-detection-algorithm-can-you-wake-up" data-astro-cid-zekvapgs> Phase 3: The detection algorithm (can you wake up?) </a>  </li> <li data-astro-cid-zekvapgs> <a href="#phase-4-partitioning-runnable-vs-leaked" id="toc-phase-4-partitioning-runnable-vs-leaked" data-astro-cid-zekvapgs> Phase 4: Partitioning (runnable vs. leaked) </a>  </li> <li data-astro-cid-zekvapgs> <a href="#phase-5-status-change-marking-the-leaked" id="toc-phase-5-status-change-marking-the-leaked" data-astro-cid-zekvapgs> Phase 5: Status change (marking the leaked) </a>  </li> <li data-astro-cid-zekvapgs> <a href="#phase-6-cleanup-and-profile-generation" id="toc-phase-6-cleanup-and-profile-generation" data-astro-cid-zekvapgs> Phase 6: Cleanup and profile generation </a>  </li> <li data-astro-cid-zekvapgs> <a href="#the-iterative-nature" id="toc-the-iterative-nature" data-astro-cid-zekvapgs> The iterative nature </a>  </li> <li data-astro-cid-zekvapgs> <a href="#what-gets-detected-and-what-doesnt" id="toc-what-gets-detected-and-what-doesnt" data-astro-cid-zekvapgs> What gets detected (and what doesn’t) </a>  </li> <li data-astro-cid-zekvapgs> <a href="#the-cleverness" id="toc-the-cleverness" data-astro-cid-zekvapgs> The cleverness </a>  </li> <li data-astro-cid-zekvapgs> <a href="#whats-next" id="toc-whats-next" data-astro-cid-zekvapgs> What’s next </a>  </li>  </ul> </nav> <script type="module">const c=document.getElementById("toc");c&&c?.addEventListener("click",t=>{const n=window.location.hash.slice(1),e=document.getElementById(`toc-${n}`);e instanceof HTMLElement&&e?.classList.remove("active-toc"),t.target instanceof HTMLElement&&t.target.classList.add("active-toc")});</script> </aside> </main> <footer class="mt-auto flex w-full flex-col items-center justify-center gap-y-2 pb-4 pt-20 text-center align-top font-semibold sm:flex-row sm:justify-between sm:text-xs text-textColor mb-8"> <div class="mr-2 sm:mr-0">
Copyright &copy; 2025  Alex Rios </div> <nav aria-label="More on this site" class="gap-x-0 sm:gap-x-2 sm:flex sm:divide-x sm:divide-accent"> <a href="/" class="px-2 py-0 hover:text-textColor hover:underline sm:px-4 sm:py-2"> Home </a><a href="/about" class="px-2 py-0 hover:text-textColor hover:underline sm:px-4 sm:py-2"> About </a><a href="/blog" class="px-2 py-0 hover:text-textColor hover:underline sm:px-4 sm:py-2"> Blog </a><a href="/books" class="px-2 py-0 hover:text-textColor hover:underline sm:px-4 sm:py-2"> Books </a><a href="/speaker" class="px-2 py-0 hover:text-textColor hover:underline sm:px-4 sm:py-2"> Speaker </a><a href="/archive" class="px-2 py-0 hover:text-textColor hover:underline sm:px-4 sm:py-2"> Archive </a> </nav> </footer> </body></html> <script type="module">const n='<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24"><path fill="currentColor" d="M6 19V1h9l6 6v12zm8-11h5l-5-5zM2 23V7h2v14h11v2z"/></svg>',i=Array.from(document.querySelectorAll("pre.astro-code"));for(const t of i){let o=t.parentElement;if(o){let c=document.createElement("div");o.replaceChild(c,t),c.classList.add("relative"),c.appendChild(t);const e=document.createElement("button");e.className="cody-copy-code",e.innerHTML=n,e.title="Copy code block",t.setAttribute("tabindex","0"),c.appendChild(e),e.addEventListener("click",async()=>{await r(t,e)})}}async function r(t,o){const e=t.querySelector("code")?.innerText??"";await navigator.clipboard.writeText(e),o.innerText="Code Copied",setTimeout(()=>{o.innerHTML=n},700)}</script>